
R version 4.3.3 (2024-02-29) -- "Angel Food Cake"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-conda-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> ### High dimension linear model
> rm(list = ls())
> 
> mywd='/home/mde4023/FDR_Datasplitting'
> setwd(mywd)
> 
> source(paste0(mywd,'/Functions/HelperFunctions.R'))
> source(paste0(mywd,'/Scenario/Scenario3b/TriangleLassoHD.R'))
> 
> source(paste0(mywd,'/Functions Dai/knockoff.R'))
> source(paste0(mywd,'/Functions Dai/analysis.R'))
> source(paste0(mywd,'/Functions Dai/MBHq.R'))
> source(paste0(mywd,'/Functions Dai/DS.R'))
> source(paste0(mywd,'/Functions Dai/fdp_power.R'))
> 
> #devtools::install_github("Jeremy690/DSfdr/DSfdr",force = TRUE)
> library(MASS)
> library(glmnet)
Loading required package: Matrix
Loaded glmnet 4.1-10
> library(knockoff)

Attaching package: â€˜knockoffâ€™

The following object is masked _by_ â€˜.GlobalEnvâ€™:

    create.solve_equi

> library(mvtnorm)
> library(hdi)
Loading required package: scalreg
Loading required package: lars
Loaded lars 1.3


Attaching package: â€˜hdiâ€™

The following object is masked _by_ â€˜.GlobalEnvâ€™:

    multi.split

> library(parallel)
> 
> ### algorithmic settings
> num_split <- 50
> n <-400
> p <- 500
> p0 <- 25
> q <- 0.1
> set.seed(456)
> signal_index <- sample(c(1:p), size = p0, replace = F)
> 
> #######set up the method for the comparison############# 
> Compare_SignalStrength <- function(i, s) {
+   set.seed(s)
+   delta <- i
+   # simulate data
+   n1 <- floor(n/2); n2 <- n - n1
+   X1 <- matrix(rnorm(n1*p, mean= -1), n1, p)
+   X2 <- matrix(rnorm(n2*p, mean= 1), n2, p)
+   X  <- rbind(X1, X2)
+   beta_star <- numeric(p)
+   beta_star[signal_index] <- rnorm(p0, 0, delta*sqrt(log(p)/n))
+   y <- (X %*% beta_star + rnorm(n))
+   
+   # run your custom methods
+   g1 <- ApplyTriangleLassoHD( X = X, y = y, q = q, num_split = num_split,
+                                  signal_index = signal_index, myseed = 1)
+   print(g1)
+   # FDR methods
+   DS_result      <- DS(          X = X, y = y, q = q, num_split = num_split)
+   knockoff_result<- knockoff(    X = X, y = y, q = q)
+   BH_result      <- MBHq(        X = X, y = y, q = q, num_split = num_split)
+   
+   # init empty results df
+   ResultsDataFrame <- data.frame(
+     Method = character(),
+     Delta  = numeric(),
+     FDP    = numeric(),
+     Power  = numeric(),
+     stringsAsFactors = FALSE
+   )
+   
+   # bind all rows
+   ResultsDataFrame <- rbind(
+     ResultsDataFrame,
+     data.frame(Method = "Boost DS",                Delta = i, FDP = g1$DS_fdp,    Power = g1$DS_power),
+     data.frame(Method = "Boost MS",                Delta = i, FDP = g1$MDS_fdp,   Power = g1$MDS_power),
+     data.frame(Method = "DataSplitting",           Delta = i, FDP = DS_result$DS_fdp,  Power = DS_result$DS_power),
+     data.frame(Method = "MultipleDataSplitting",   Delta = i, FDP = DS_result$MDS_fdp, Power = DS_result$MDS_power),
+     data.frame(Method = "Knockoff",                Delta = i, FDP = knockoff_result$fdp, Power = knockoff_result$power),
+     data.frame(Method = "Benjamini-Hochberg (BH)", Delta = i, FDP = BH_result$fdp,     Power = BH_result$power)
+   )
+   
+   return(ResultsDataFrame)
+ }
> 
> 
> #######run the code#############
> # Dai’s routines
> source(file.path(mywd, 'Functions Dai', 'analysis.R'))
> source(file.path(mywd, 'Functions Dai', 'MBHq.R'))
> source(file.path(mywd, 'Functions Dai', 'DS.R'))
> source(file.path(mywd, 'Functions Dai', 'fdp_power.R'))
> 
> # Load required packages
> pkgs <- c('gbm','MASS','glmnet','knockoff','mvtnorm','hdi',
+           'foreach','doParallel')
> lapply(pkgs, library, character.only = TRUE)
Loaded gbm 2.2.2
This version of gbm is no longer under development. Consider transitioning to gbm3, https://github.com/gbm-developers/gbm3
Loading required package: iterators
[[1]]
 [1] "gbm"       "parallel"  "hdi"       "scalreg"   "lars"      "mvtnorm"  
 [7] "knockoff"  "glmnet"    "Matrix"    "MASS"      "stats"     "graphics" 
[13] "grDevices" "utils"     "datasets"  "methods"   "base"     

[[2]]
 [1] "gbm"       "parallel"  "hdi"       "scalreg"   "lars"      "mvtnorm"  
 [7] "knockoff"  "glmnet"    "Matrix"    "MASS"      "stats"     "graphics" 
[13] "grDevices" "utils"     "datasets"  "methods"   "base"     

[[3]]
 [1] "gbm"       "parallel"  "hdi"       "scalreg"   "lars"      "mvtnorm"  
 [7] "knockoff"  "glmnet"    "Matrix"    "MASS"      "stats"     "graphics" 
[13] "grDevices" "utils"     "datasets"  "methods"   "base"     

[[4]]
 [1] "gbm"       "parallel"  "hdi"       "scalreg"   "lars"      "mvtnorm"  
 [7] "knockoff"  "glmnet"    "Matrix"    "MASS"      "stats"     "graphics" 
[13] "grDevices" "utils"     "datasets"  "methods"   "base"     

[[5]]
 [1] "gbm"       "parallel"  "hdi"       "scalreg"   "lars"      "mvtnorm"  
 [7] "knockoff"  "glmnet"    "Matrix"    "MASS"      "stats"     "graphics" 
[13] "grDevices" "utils"     "datasets"  "methods"   "base"     

[[6]]
 [1] "gbm"       "parallel"  "hdi"       "scalreg"   "lars"      "mvtnorm"  
 [7] "knockoff"  "glmnet"    "Matrix"    "MASS"      "stats"     "graphics" 
[13] "grDevices" "utils"     "datasets"  "methods"   "base"     

[[7]]
 [1] "foreach"   "gbm"       "parallel"  "hdi"       "scalreg"   "lars"     
 [7] "mvtnorm"   "knockoff"  "glmnet"    "Matrix"    "MASS"      "stats"    
[13] "graphics"  "grDevices" "utils"     "datasets"  "methods"   "base"     

[[8]]
 [1] "doParallel" "iterators"  "foreach"    "gbm"        "parallel"  
 [6] "hdi"        "scalreg"    "lars"       "mvtnorm"    "knockoff"  
[11] "glmnet"     "Matrix"     "MASS"       "stats"      "graphics"  
[16] "grDevices"  "utils"      "datasets"   "methods"    "base"      

> 
> # === PARAMETER GRID ===
> param_grid <- expand.grid(
+   s = 1:200,
+   i = seq(from = 7, to = 10, by = 1)
+ )
> ncore <- min(detectCores() - 1, 5)
> # === SET UP PARALLEL BACKEND ===
> cl <- makeCluster(ncore)
> # export working dir so workers can source
> clusterExport(cl, 'mywd')
> # have each worker source & load libraries
> clusterEvalQ(cl, {
+   setwd(mywd)
+   source(paste0(mywd,'/Scenario/Scenario3b/TriangleLassoHD.R'))
+   source(file.path(mywd, 'Functions', 'HelperFunctions.R'))
+   source(file.path(mywd, 'Functions Dai', 'knockoff.R'))
+   source(file.path(mywd, 'Functions Dai', 'analysis.R'))
+   source(file.path(mywd, 'Functions Dai', 'MBHq.R'))
+   source(file.path(mywd, 'Functions Dai', 'DS.R'))
+   source(file.path(mywd, 'Functions Dai', 'fdp_power.R'))
+   lapply(c('gbm','MASS','glmnet','knockoff','mvtnorm','hdi'),
+          library, character.only = TRUE)
+ })
[[1]]
[[1]][[1]]
[1] "gbm"       "stats"     "graphics"  "grDevices" "utils"     "datasets" 
[7] "methods"   "base"     

[[1]][[2]]
[1] "MASS"      "gbm"       "stats"     "graphics"  "grDevices" "utils"    
[7] "datasets"  "methods"   "base"     

[[1]][[3]]
 [1] "glmnet"    "Matrix"    "MASS"      "gbm"       "stats"     "graphics" 
 [7] "grDevices" "utils"     "datasets"  "methods"   "base"     

[[1]][[4]]
 [1] "knockoff"  "glmnet"    "Matrix"    "MASS"      "gbm"       "stats"    
 [7] "graphics"  "grDevices" "utils"     "datasets"  "methods"   "base"     

[[1]][[5]]
 [1] "mvtnorm"   "knockoff"  "glmnet"    "Matrix"    "MASS"      "gbm"      
 [7] "stats"     "graphics"  "grDevices" "utils"     "datasets"  "methods"  
[13] "base"     

[[1]][[6]]
 [1] "hdi"       "scalreg"   "lars"      "mvtnorm"   "knockoff"  "glmnet"   
 [7] "Matrix"    "MASS"      "gbm"       "stats"     "graphics"  "grDevices"
[13] "utils"     "datasets"  "methods"   "base"     


[[2]]
[[2]][[1]]
[1] "gbm"       "stats"     "graphics"  "grDevices" "utils"     "datasets" 
[7] "methods"   "base"     

[[2]][[2]]
[1] "MASS"      "gbm"       "stats"     "graphics"  "grDevices" "utils"    
[7] "datasets"  "methods"   "base"     

[[2]][[3]]
 [1] "glmnet"    "Matrix"    "MASS"      "gbm"       "stats"     "graphics" 
 [7] "grDevices" "utils"     "datasets"  "methods"   "base"     

[[2]][[4]]
 [1] "knockoff"  "glmnet"    "Matrix"    "MASS"      "gbm"       "stats"    
 [7] "graphics"  "grDevices" "utils"     "datasets"  "methods"   "base"     

[[2]][[5]]
 [1] "mvtnorm"   "knockoff"  "glmnet"    "Matrix"    "MASS"      "gbm"      
 [7] "stats"     "graphics"  "grDevices" "utils"     "datasets"  "methods"  
[13] "base"     

[[2]][[6]]
 [1] "hdi"       "scalreg"   "lars"      "mvtnorm"   "knockoff"  "glmnet"   
 [7] "Matrix"    "MASS"      "gbm"       "stats"     "graphics"  "grDevices"
[13] "utils"     "datasets"  "methods"   "base"     


[[3]]
[[3]][[1]]
[1] "gbm"       "stats"     "graphics"  "grDevices" "utils"     "datasets" 
[7] "methods"   "base"     

[[3]][[2]]
[1] "MASS"      "gbm"       "stats"     "graphics"  "grDevices" "utils"    
[7] "datasets"  "methods"   "base"     

[[3]][[3]]
 [1] "glmnet"    "Matrix"    "MASS"      "gbm"       "stats"     "graphics" 
 [7] "grDevices" "utils"     "datasets"  "methods"   "base"     

[[3]][[4]]
 [1] "knockoff"  "glmnet"    "Matrix"    "MASS"      "gbm"       "stats"    
 [7] "graphics"  "grDevices" "utils"     "datasets"  "methods"   "base"     

[[3]][[5]]
 [1] "mvtnorm"   "knockoff"  "glmnet"    "Matrix"    "MASS"      "gbm"      
 [7] "stats"     "graphics"  "grDevices" "utils"     "datasets"  "methods"  
[13] "base"     

[[3]][[6]]
 [1] "hdi"       "scalreg"   "lars"      "mvtnorm"   "knockoff"  "glmnet"   
 [7] "Matrix"    "MASS"      "gbm"       "stats"     "graphics"  "grDevices"
[13] "utils"     "datasets"  "methods"   "base"     


[[4]]
[[4]][[1]]
[1] "gbm"       "stats"     "graphics"  "grDevices" "utils"     "datasets" 
[7] "methods"   "base"     

[[4]][[2]]
[1] "MASS"      "gbm"       "stats"     "graphics"  "grDevices" "utils"    
[7] "datasets"  "methods"   "base"     

[[4]][[3]]
 [1] "glmnet"    "Matrix"    "MASS"      "gbm"       "stats"     "graphics" 
 [7] "grDevices" "utils"     "datasets"  "methods"   "base"     

[[4]][[4]]
 [1] "knockoff"  "glmnet"    "Matrix"    "MASS"      "gbm"       "stats"    
 [7] "graphics"  "grDevices" "utils"     "datasets"  "methods"   "base"     

[[4]][[5]]
 [1] "mvtnorm"   "knockoff"  "glmnet"    "Matrix"    "MASS"      "gbm"      
 [7] "stats"     "graphics"  "grDevices" "utils"     "datasets"  "methods"  
[13] "base"     

[[4]][[6]]
 [1] "hdi"       "scalreg"   "lars"      "mvtnorm"   "knockoff"  "glmnet"   
 [7] "Matrix"    "MASS"      "gbm"       "stats"     "graphics"  "grDevices"
[13] "utils"     "datasets"  "methods"   "base"     


[[5]]
[[5]][[1]]
[1] "gbm"       "stats"     "graphics"  "grDevices" "utils"     "datasets" 
[7] "methods"   "base"     

[[5]][[2]]
[1] "MASS"      "gbm"       "stats"     "graphics"  "grDevices" "utils"    
[7] "datasets"  "methods"   "base"     

[[5]][[3]]
 [1] "glmnet"    "Matrix"    "MASS"      "gbm"       "stats"     "graphics" 
 [7] "grDevices" "utils"     "datasets"  "methods"   "base"     

[[5]][[4]]
 [1] "knockoff"  "glmnet"    "Matrix"    "MASS"      "gbm"       "stats"    
 [7] "graphics"  "grDevices" "utils"     "datasets"  "methods"   "base"     

[[5]][[5]]
 [1] "mvtnorm"   "knockoff"  "glmnet"    "Matrix"    "MASS"      "gbm"      
 [7] "stats"     "graphics"  "grDevices" "utils"     "datasets"  "methods"  
[13] "base"     

[[5]][[6]]
 [1] "hdi"       "scalreg"   "lars"      "mvtnorm"   "knockoff"  "glmnet"   
 [7] "Matrix"    "MASS"      "gbm"       "stats"     "graphics"  "grDevices"
[13] "utils"     "datasets"  "methods"   "base"     


> registerDoParallel(cl)
> 
> # === RUN IN PARALLEL AND WRITE OUT ===
> results_list <- foreach(
+   k = seq_len(nrow(param_grid)),
+   .packages = pkgs,
+   .combine  = rbind
+ ) %dopar% {
+   s_val <- param_grid$s[k]
+   i_val <- param_grid$i[k]
+   
+   # compute chunk of results
+   chunk <- Compare_SignalStrength(i = i_val, s = s_val)
+   
+   # write out this chunk immediately
+   fname <- sprintf("Results_s%02d_i%02d.csv", s_val, i_val)
+   write.csv(chunk, file = paste0("/home/mde4023/FDR_Datasplitting/Scenario/Scenario3b/Temp2/",fname), row.names = FALSE)
+   
+   # return for final binding
+   chunk
+ }
> 
> # === CLEANUP AND FINAL SAVE ===
> stopCluster(cl)
> warnings()
> # combine all and save full dataset
> Results <- results_list
> write.csv(Results, file = "ResultsHDScenario.csv", row.names = FALSE)
> 
> 
> proc.time()
     user    system   elapsed 
    7.525     0.434 79919.730 

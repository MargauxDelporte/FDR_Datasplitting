
R version 4.3.3 (2024-02-29) -- "Angel Food Cake"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-conda-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> ### High dimension linear model
> rm(list = ls())
> 
> mywd='/home/mde4023/FDR_Datasplitting'
> setwd(mywd)
> 
> source(paste0(mywd,'/Functions/HelperFunctions.R'))
> source(paste0(mywd,'/Functions/ApplyGBMKnockoff.R'))
> source(paste0(mywd,'/Scenario/Scenario2/MarsParallelNL.R'))
> 
> source(paste0(mywd,'/Functions Dai/knockoff.R'))
> source(paste0(mywd,'/Functions Dai/analysis.R'))
> source(paste0(mywd,'/Functions Dai/MBHq.R'))
> source(paste0(mywd,'/Functions Dai/DS.R'))
> source(paste0(mywd,'/Functions Dai/fdp_power.R'))
> 
> library(xgboost)
> library(gbm)
Loaded gbm 2.2.2
This version of gbm is no longer under development. Consider transitioning to gbm3, https://github.com/gbm-developers/gbm3
> library(ranger)
> library(MASS)
> 
> library(glmnet)
Loading required package: Matrix
Loaded glmnet 4.1-10
> library(knockoff)

Attaching package: ‘knockoff’

The following object is masked _by_ ‘.GlobalEnv’:

    create.solve_equi

> library(mvtnorm)
> library(hdi)
Loading required package: scalreg
Loading required package: lars
Loaded lars 1.3


Attaching package: ‘hdi’

The following object is masked _by_ ‘.GlobalEnv’:

    multi.split

> library(parallel)
> library(foreach)
> library(doParallel)
> 
> ## algorithmic settings
> num_split <- 50
> n <-500
> p <- 100
> p0 <- 10
> q <- 0.1
> 
> ###choose the parameters
> params =list(
+   objective = "reg:squarederror",
+   eta       = 0.005,
+   max_depth = 6,
+   lambda    = 0,
+   alpha     = 0
+ )
> set.seed(456)
> signal_index <- sample(c(1:p), size = p0, replace = F)
> 
> #######set up the method for the comparison############# 
> Compare_SignalStrength <- function(i, s) {
+   set.seed(s)
+   delta <- i
+   signal_index <- sample(c(1:p), size = p0, replace = F)
+   # simulate data
+   n1 <- floor(n/2); n2 <- n - n1
+   X1 <- matrix(rnorm(n1*p, mean= 1), n1, p)
+   X2 <- matrix(rnorm(n2*p, mean=-1), n2, p)
+   X  <- rbind(X1, X2)
+   beta_star <- numeric(p)
+   beta_star[signal_index] <- rnorm(p0, 0, delta*sqrt(log(p)/n))*10
+   y <- (X^2 %*% beta_star + rnorm(n))
+   
+   # run your custom methods
+   g1 <- ApplyMarsTrain_parallel( X = X, y = y, q = q, num_split = num_split,signal_index = signal_index, myseed = 1)
+   # FDR methods
+   DS_result      <- DS(          X = X, y = y, q = q, num_split = num_split)
+   knockoff_result<- ApplyGBMKnockoff(    X = X, y = y, q = q,param=params)
+   BH_result      <- MBHq(        X = X, y = y, q = q, num_split = num_split)
+   
+   # init empty results df
+   ResultsDataFrame <- data.frame(
+     Method = character(),
+     Delta  = numeric(),
+     FDP    = numeric(),
+     Power  = numeric(),
+     stringsAsFactors = FALSE
+   )
+   
+   # bind all rows
+   ResultsDataFrame <- rbind(
+     ResultsDataFrame,
+     data.frame(Method = "Mars DS",                Delta = i, FDP = g1$DS_fdp,    Power = g1$DS_power),
+     data.frame(Method = "Mars MS",                Delta = i, FDP = g1$MDS_fdp,   Power = g1$MDS_power),
+     data.frame(Method = "DataSplitting",           Delta = i, FDP = DS_result$DS_fdp,  Power = DS_result$DS_power),
+     data.frame(Method = "MultipleDataSplitting",   Delta = i, FDP = DS_result$MDS_fdp, Power = DS_result$MDS_power),
+     data.frame(Method = "Knockoff",                Delta = i, FDP = knockoff_result$fdp, Power = knockoff_result$power),
+     data.frame(Method = "Benjamini-Hochberg (BH)", Delta = i, FDP = BH_result$fdp,     Power = BH_result$power)
+   )
+   
+   return(ResultsDataFrame)
+ }
> 
> # build grid
> param_grid <- expand.grid(
+   s = 1:200,
+   i = 7:13
+ )
> 
> # make sure output dir exists
> out_dir <- file.path(mywd, "Scenario/Scenario2/Temp2")
> dir.create(out_dir, recursive = TRUE, showWarnings = FALSE)
> 
> # iterate over ROWS, not columns
> for (k in seq_len(nrow(param_grid))) {
+   s_val <- param_grid$s[k]
+   i_val <- param_grid$i[k]
+   
+   # compute chunk (wrap in tryCatch to avoid breaking the whole run)
+   chunk <- tryCatch(
+     Compare_SignalStrength(i = i_val, s = s_val),
+     error = function(e) {
+       message(sprintf("Failed at s=%s, i=%s: %s", s_val, i_val, conditionMessage(e)))
+       return(NULL)
+     }
+   )
+   if (is.null(chunk)) next
+   if (!is.data.frame(chunk)) chunk <- as.data.frame(chunk)
+   
+   # write out this chunk immediately
+   fname <- sprintf("Results_s%02d_i%02d.csv", s_val, i_val)
+   write.csv(chunk, file = file.path(out_dir, fname), row.names = FALSE)
+ }
> 
> # === CLEANUP AND FINAL SAVE ===
> 
> # Path to your folder
> # === CLEANUP AND FINAL SAVE ===
> 
> # Path to your folder
> csv_files <- list.files(
+   path       = out_dir,
+   pattern    = "\\.csv$",
+   full.names = TRUE
+ )
> warnings()
> 
> 
> proc.time()
    user   system  elapsed 
81752.20   338.61 20780.39 

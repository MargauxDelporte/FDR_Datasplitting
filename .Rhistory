)
}))
# Filter for valid results
valid_results <- results_df[results_df$converged & !is.na(results_df$fdp), ]
if (nrow(valid_results) == 0) {
warning("No valid configurations found!")
return(list(
best_params = NULL,
all_results = results_df,
fdr_controlled_results = NULL
))
}
# Filter for FDR control
fdr_controlled <- valid_results[valid_results$fdp <= fdr_threshold, ]
if (nrow(fdr_controlled) == 0) {
warning(sprintf("No configurations achieved FDR <= %.2f", fdr_threshold))
# Return best overall FDR instead
best_idx <- which.min(valid_results$fdp)
best_params <- valid_results[best_idx, ]
} else {
# Among FDR-controlled configs, find max power
best_idx <- which.max(fdr_controlled$power)
best_params <- fdr_controlled[best_idx, ]
}
if (verbose) {
cat("\n=== Tuning Results ===\n")
cat(sprintf("Total configurations tested: %d\n", n_configs))
cat(sprintf("Valid configurations: %d\n", nrow(valid_results)))
cat(sprintf("FDR-controlled (FDR <= %.2f): %d\n", fdr_threshold, nrow(fdr_controlled)))
cat("\n=== Best Configuration ===\n")
cat(sprintf("Degree: %d\n", best_params$degree))
cat(sprintf("Nprune: %s\n", ifelse(is.na(best_params$nprune), "NULL (auto)", best_params$nprune)))
cat(sprintf("Minspan: %d\n", best_params$minspan))
cat(sprintf("Thresh: %.4f\n", best_params$thresh))
cat(sprintf("\nFDP: %.4f\n", best_params$fdp))
cat(sprintf("Power: %.4f\n", best_params$power))
cat(sprintf("R2 (fold 1): %.4f\n", best_params$R2_1))
cat(sprintf("R2 (fold 2): %.4f\n", best_params$R2_2))
cat(sprintf("# Selected: %d\n", best_params$n_selected))
cat(sprintf("# MARS terms: %d\n", best_params$n_terms))
}
# Sort results by power (descending) for FDR-controlled
if (nrow(fdr_controlled) > 0) {
fdr_controlled <- fdr_controlled[order(-fdr_controlled$power), ]
}
return(list(
best_params = best_params,
all_results = results_df,
fdr_controlled_results = fdr_controlled,
valid_results = valid_results,
fdr_threshold = fdr_threshold
))
}
### algorithmic settings
num_split <- 5
n <-400
p <- 500
p0 <- 25
q <- 0.1
set.seed(12)
signal_index <- sample(c(1:p), size = p0, replace = F)
n1 <- floor(n/2); n2 <- n - n1
X1 <- matrix(rnorm(n1*p, mean= -1), n1, p)
X2 <- matrix(rnorm(n2*p, mean= 1), n2, p)
X  <- rbind(X1, X2)
beta_star <- numeric(p)
beta_star[signal_index] <- rnorm(p0, 0, delta*sqrt(log(p)/n))
y <- (X %*% beta_star + rnorm(n))
amountTrain=0.333
amountTest=1-amountTrain
data<-data.frame(cbind(y,X))
n <- dim(X)[1]
p <- dim(X)[2]
# --- indices ---
train_index <- sample.int(n, size = floor(amountTrain * n), replace = FALSE)
remaining_index <- setdiff(seq_len(n), train_index)
data<-data.frame(cbind(y,X))
remaining_index<-c(setdiff(c(1:n),train_index))
sample_index1 <- sample(x = remaining_index, size = amountTest/2 * n, replace = F)
sample_index2 <- setdiff(remaining_index, sample_index1)
myresults2=tune_mars_hyperparameters2(X, y, sample_index1, sample_index2, signal_index, q,
permR2Mars_func=permR2Mars, SelectFeatures_func=SelectFeatures,
CalculateFDP_Power_func=CalculateFDP_Power,
fdr_threshold = 0.10)
myresults2
myresults3=subset(myresults2,myresults2$fdp<0.10&myresults2$power>0.80)
myresults3
myresults2
ttt=myresults2$all_results
ttt
myresults3=subset(ttt,ttt$fdp<0.10&ttt$power>0.80)
myresults3
tuning_grid=myresults3[,1:5]
tuning_grid
tuning_grid=myresults3[,1:4]
tuning_grid
num_split <- 5
n <-400
p <- 500
p0 <- 25
q <- 0.1
set.seed(8)
signal_index <- sample(c(1:p), size = p0, replace = F)
n1 <- floor(n/2); n2 <- n - n1
X1 <- matrix(rnorm(n1*p, mean= -1), n1, p)
X2 <- matrix(rnorm(n2*p, mean= 1), n2, p)
X  <- rbind(X1, X2)
beta_star <- numeric(p)
beta_star[signal_index] <- rnorm(p0, 0, delta*sqrt(log(p)/n))
y <- (X %*% beta_star + rnorm(n))
amountTrain=0.333
amountTest=1-amountTrain
data<-data.frame(cbind(y,X))
n <- dim(X)[1]
p <- dim(X)[2]
# --- indices ---
train_index <- sample.int(n, size = floor(amountTrain * n), replace = FALSE)
remaining_index <- setdiff(seq_len(n), train_index)
data<-data.frame(cbind(y,X))
remaining_index<-c(setdiff(c(1:n),train_index))
sample_index1 <- sample(x = remaining_index, size = amountTest/2 * n, replace = F)
sample_index2 <- setdiff(remaining_index, sample_index1)
myresults4=tune_mars_hyperparameters2(X, y, sample_index1, sample_index2, signal_index, q,
permR2Mars_func=permR2Mars, SelectFeatures_func=SelectFeatures,
CalculateFDP_Power_func=CalculateFDP_Power,
fdr_threshold = 0.10)
myresults4
myresults4
ttt=myresults4$all_results
ttt=myresults4$all_results
tuning_grid=subset(ttt,ttt$fdp<0.10&ttt$power>0.80)
tuning_grid
myresults4$all_results
ttt=myresults4$all_results
tuning_grid=subset(ttt,ttt$fdp<0.10&ttt$power>0.80)
tuning_grid
ttt=myresults4$all_results
tuning_grid=subset(ttt,ttt$fdp<0.10&ttt$power>0.80)
num_split <- 5
n <-400
p <- 500
p0 <- 25
q <- 0.1
set.seed(201)
signal_index <- sample(c(1:p), size = p0, replace = F)
n1 <- floor(n/2); n2 <- n - n1
X1 <- matrix(rnorm(n1*p, mean= -1), n1, p)
X2 <- matrix(rnorm(n2*p, mean= 1), n2, p)
X  <- rbind(X1, X2)
beta_star <- numeric(p)
beta_star[signal_index] <- rnorm(p0, 0, delta*sqrt(log(p)/n))
y <- (X %*% beta_star + rnorm(n))
amountTrain=0.333
amountTest=1-amountTrain
data<-data.frame(cbind(y,X))
n <- dim(X)[1]
p <- dim(X)[2]
# --- indices ---
train_index <- sample.int(n, size = floor(amountTrain * n), replace = FALSE)
remaining_index <- setdiff(seq_len(n), train_index)
data<-data.frame(cbind(y,X))
remaining_index<-c(setdiff(c(1:n),train_index))
sample_index1 <- sample(x = remaining_index, size = amountTest/2 * n, replace = F)
sample_index2 <- setdiff(remaining_index, sample_index1)
myresults5=tune_mars_hyperparameters2(X, y, sample_index1, sample_index2, signal_index, q,
permR2Mars_func=permR2Mars, SelectFeatures_func=SelectFeatures,
CalculateFDP_Power_func=CalculateFDP_Power,
fdr_threshold = 0.10)
ttt=myresults5$all_results
tuning_grid=subset(ttt,ttt$fdp<0.10&ttt$power>0.80)
tuning_grid
### High dimension linear model
rm(list = ls())
mywd='C:/Users/mde4023/Downloads/FDR_Datasplitting'
setwd(mywd)
source(paste0(mywd,'/Functions/HelperFunctions.R'))
#source(paste0(mywd,'/Scenario/Scenario3b/TriangleLassoHD.R'))
source(paste0(mywd,'/Scenario/Scenario3b/MarsParallelHD.R'))
source(paste0(mywd,'/Functions Dai/knockoff.R'))
source(paste0(mywd,'/Functions Dai/analysis.R'))
source(paste0(mywd,'/Functions Dai/MBHq.R'))
source(paste0(mywd,'/Functions Dai/DS.R'))
source(paste0(mywd,'/Functions Dai/fdp_power.R'))
#devtools::install_github("Jeremy690/DSfdr/DSfdr",force = TRUE)
library(MASS)
library(glmnet)
library(knockoff)
library(mvtnorm)
library(hdi)
library(parallel)
### algorithmic settings
num_split <- 5
n <-400
p <- 500
p0 <- 25
q <- 0.1
set.seed(456)
signal_index <- sample(c(1:p), size = p0, replace = F)
#######set up the method for the comparison#############  s=15;i=10
Compare_SignalStrength <- function(i, s) {
set.seed(s)
delta <- i
# simulate data
n1 <- floor(n/2); n2 <- n - n1
X1 <- matrix(rnorm(n1*p, mean= -1), n1, p)
X2 <- matrix(rnorm(n2*p, mean= 1), n2, p)
X  <- rbind(X1, X2)
beta_star <- numeric(p)
beta_star[signal_index] <- rnorm(p0, 0, delta*sqrt(log(p)/n))*10
y <- (X %*% beta_star + rnorm(n))
# run your custom methods
g1 <- ApplyMarsTrain_HDparallel( X = X, y = y, q = q, num_split = num_split,
signal_index = signal_index, myseed = 1)
print(g1)
# FDR methods
DS_result      <- DS(          X = X, y = y, q = q, num_split = num_split)
knockoff_result<- knockoff(    X = X, y = y, q = q)
BH_result      <- MBHq(        X = X, y = y, q = q, num_split = num_split)
# init empty results df
ResultsDataFrame <- data.frame(
Method = character(),
Delta  = numeric(),
FDP    = numeric(),
Power  = numeric(),
stringsAsFactors = FALSE
)
# bind all rows
ResultsDataFrame <- rbind(
ResultsDataFrame,
data.frame(Method = "Boost DS",                Delta = i, FDP = g1$DS_fdp,    Power = g1$DS_power),
data.frame(Method = "Boost MS",                Delta = i, FDP = g1$MDS_fdp,   Power = g1$MDS_power),
data.frame(Method = "DataSplitting",           Delta = i, FDP = DS_result$DS_fdp,  Power = DS_result$DS_power),
data.frame(Method = "MultipleDataSplitting",   Delta = i, FDP = DS_result$MDS_fdp, Power = DS_result$MDS_power),
data.frame(Method = "Knockoff",                Delta = i, FDP = knockoff_result$fdp, Power = knockoff_result$power),
data.frame(Method = "Benjamini-Hochberg (BH)", Delta = i, FDP = BH_result$fdp,     Power = BH_result$power)
)
return(ResultsDataFrame)
}
Compare_SignalStrength(i=10,s=5)
View(ApplyMarsTrain_HDparallel)
suppressPackageStartupMessages({
library(earth)        # MARS
library(foreach)
library(doParallel)
library(doRNG)        # reproducible %dopar%
})
#setwd("~/Desktop/temp") j=1 model=lm
permR2Mars<-function(data,Y,j,model){
Xperm <- data
Xperm[, j] <- sample(data[, j], replace = FALSE)
pred_perm <- predict(model, newdata = as.data.frame(Xperm))
rsq_perm <- 1 - sum((Y - pred_perm)^2) / sum((Y - mean(Y))^2)
rsq_perm
return(rsq_perm)
}
ApplyMarsTrain_HDparallel <- function(X, y, q=q,mynk,myprune, myseed=1,num_split = 50,
signal_index = signal_index,plot_hist = FALSE) {
stopifnot(nrow(X) == length(y))
set.seed(myseed)
amountTrain <- 0.5
amountTest  <- 1 - amountTrain
n <- nrow(X); p <- ncol(X)
data <- data.frame(cbind(y, X))
colnames(data) <- c("y", paste0("X", 1:p))
# ---- parallel backend ----
n_cores <- max(1, parallel::detectCores(logical = TRUE) - 1)
cl <- parallel::makeCluster(n_cores)
doParallel::registerDoParallel(cl)
# Weâ€™ll collect per-split:
# [1] num_selected, [2] fdp, [3] power,
# [4] R2orig1, [5] R2orig2, [6:(5+p)] inclusion_rate_row (length p)
res_mat <- foreach(iter = 1:num_split,
.combine = "rbind",
.packages = c("earth"),
.export   = c("permR2Mars","SelectFeatures","CalculateFDP_Power")) %dorng% {
# --- indices ---
train_index <- sample.int(n, size = floor(amountTrain * n), replace = FALSE)
remaining_index <- setdiff(seq_len(n), train_index)
# split the remaining half evenly
size_half <- floor((amountTest/2) * n)
sample_index1 <- sample(remaining_index, size = size_half, replace = FALSE)
sample_index2 <- setdiff(remaining_index, sample_index1)
dataTrain <- data[train_index, , drop = FALSE]
mars_poly= earth(
y ~ .,
pmethod="cv",
nfold=5,
minspan=1,
thresh=0.001,
degree=2,
nprune=30,
data    = dataTrain
)
lm <- mars_poly
lm
# --- R^2 on train (not stored) / test halves (stored) ---
pred1 <- predict(lm, newdata = as.data.frame(X[sample_index1, , drop = FALSE]))
pred2 <- predict(lm, newdata = as.data.frame(X[sample_index2, , drop = FALSE]))
y1 <- y[sample_index1]; y2 <- y[sample_index2]
R2orig1 <- 1 - sum((y1 - pred1)^2) / sum((y1 - mean(y1))^2)
R2orig2 <- 1 - sum((y2 - pred2)^2) / sum((y2 - mean(y2))^2)
R2orig1;R2orig2
# --- permutation-based drops ---
Rnew1 <- sapply(seq_len(p), function(j)
permR2Mars(as.data.frame(X[sample_index1, , drop = FALSE]), Y = y1, j = j, model = lm))
Rnew2 <- sapply(seq_len(p), function(j)
permR2Mars(as.data.frame(X[sample_index2, , drop = FALSE]), Y = y2, j = j, model = lm))
beta1 <- R2orig1 - Rnew1
beta2 <- R2orig2 - Rnew2
mirror <- sign(beta1 * beta2) * (abs(beta1) + abs(beta2))
#hist(mirror[-signal_index])
selected_index <- SelectFeatures(mirror, abs(mirror),q)
num_sel <- length(selected_index)
num_sel
inc_row <- numeric(p)
fdp_val <- 0
pow_val <- 0
if (num_sel > 0) {
inc_row[selected_index] <- 1 / num_sel
res <- CalculateFDP_Power(selected_index, signal_index)
fdp_val <- res$fdp
pow_val <- res$power
}
fdp_val;pow_val
c(num_sel, fdp_val, pow_val, R2orig1, R2orig2, inc_row)
}
parallel::stopCluster(cl)
# ---- unpack ----
num_select     <- res_mat[, 1]
fdp            <- res_mat[, 2]
power          <- res_mat[, 3]
R2orig1_vec    <- res_mat[, 4]
R2orig2_vec    <- res_mat[, 5]
inclusion_rate_mat <- res_mat[, -(1:5), drop = FALSE]  # num_split x p
# DS results from the *first* split (order preserved with foreach)
DS_fdp   <- fdp[1]
DS_power <- power[1]
# MDS inclusion rates (avg across splits)
inclusion_rate <- apply(inclusion_rate_mat, 2, mean)
# Rank features by empirical inclusion rate
feature_rank <- order(inclusion_rate)
feature_rank <- setdiff(feature_rank, which(inclusion_rate == 0))
if (length(feature_rank) != 0) {
null_feature <- numeric()
for (feature_index in seq_along(feature_rank)) {
if (sum(inclusion_rate[feature_rank[1:feature_index]]) > q) break
null_feature <- c(null_feature, feature_rank[feature_index])
}
selected_index <- setdiff(feature_rank, null_feature)
res_final <- CalculateFDP_Power(selected_index, signal_index)
MDS_fdp   <- res_final$fdp
MDS_power <- res_final$power
} else {
MDS_fdp <- 0
MDS_power <- 0
}
message(paste0("First R squared: ", round(R2orig1_vec[1], 3)))
message(paste0("Second R squared: ", round(R2orig2_vec[1], 3)))
message(paste0("DS_fdp = ", DS_fdp,
" DS_power = ", DS_power,
" MDS_fdp = ", MDS_fdp,
" MDS_power = ", MDS_power))
return(list(
DS_fdp   = ifelse(is.na(DS_fdp),0,DS_fdp),
DS_power = ifelse(is.na(DS_power),0,DS_power),
MDS_fdp  = MDS_fdp,
MDS_power = MDS_power)
)
}
Compare_SignalStrength(i=10,s=5)
View(ApplyMarsTrain_HDparallel)
View(ApplyMarsTrain_HDparallel)
View(ApplyMarsTrain_HDparallel)
Compare_SignalStrength(i=10,s=6)
Compare_SignalStrength(i=10,s=7)
### High dimension linear model
rm(list = ls())
mywd='C:/Users/mde4023/Downloads/FDR_Datasplitting'
setwd(mywd)
source(paste0(mywd,'/Functions/HelperFunctions.R'))
#source(paste0(mywd,'/Scenario/Scenario3c/TriangleLassoHD.R'))
source(paste0(mywd,'/Scenario/Scenario3c/MarsParallelHD.R'))
source(paste0(mywd,'/Functions Dai/knockoff.R'))
source(paste0(mywd,'/Functions Dai/analysis.R'))
source(paste0(mywd,'/Functions Dai/MBHq.R'))
source(paste0(mywd,'/Functions Dai/DS.R'))
source(paste0(mywd,'/Functions Dai/fdp_power.R'))
#devtools::install_github("Jeremy690/DSfdr/DSfdr",force = TRUE)
library(MASS)
library(glmnet)
library(knockoff)
library(mvtnorm)
library(hdi)
library(parallel)
### algorithmic settings
num_split <- 5
n <-400
p <- 500
p0 <- 25
q <- 0.1
set.seed(456)
signal_index <- sample(c(1:p), size = p0, replace = F)
#######set up the method for the comparison#############  s=15;i=10
Compare_SignalStrength <- function(i, s) {
set.seed(s)
delta <- i
# simulate data
n1 <- floor(n/2); n2 <- n - n1
X1 <- matrix(rnorm(n1*p, mean= -1), n1, p)
X2 <- matrix(rnorm(n2*p, mean= 1), n2, p)
X  <- rbind(X1, X2)
beta_star <- numeric(p)
beta_star[signal_index] <- rnorm(p0, 0, delta*sqrt(log(p)/n))*10
y <- (X %*% beta_star + rnorm(n))
# run your custom methods
g1 <- ApplyMarsTrain_HDparallel( X = X, y = y, q = q, num_split = num_split,
signal_index = signal_index, myseed = 1)
print(g1)
# FDR methods
DS_result      <- DS(          X = X, y = y, q = q, num_split = num_split)
knockoff_result<- knockoff(    X = X, y = y, q = q)
BH_result      <- MBHq(        X = X, y = y, q = q, num_split = num_split)
# init empty results df
ResultsDataFrame <- data.frame(
Method = character(),
Delta  = numeric(),
FDP    = numeric(),
Power  = numeric(),
stringsAsFactors = FALSE
)
# bind all rows
ResultsDataFrame <- rbind(
ResultsDataFrame,
data.frame(Method = "Boost DS",                Delta = i, FDP = g1$DS_fdp,    Power = g1$DS_power),
data.frame(Method = "Boost MS",                Delta = i, FDP = g1$MDS_fdp,   Power = g1$MDS_power),
data.frame(Method = "DataSplitting",           Delta = i, FDP = DS_result$DS_fdp,  Power = DS_result$DS_power),
data.frame(Method = "MultipleDataSplitting",   Delta = i, FDP = DS_result$MDS_fdp, Power = DS_result$MDS_power),
data.frame(Method = "Knockoff",                Delta = i, FDP = knockoff_result$fdp, Power = knockoff_result$power),
data.frame(Method = "Benjamini-Hochberg (BH)", Delta = i, FDP = BH_result$fdp,     Power = BH_result$power)
)
return(ResultsDataFrame)
}
Compare_SignalStrength(i=10,s=5)
Compare_SignalStrength(i=10,s=6)
### High dimension linear model
rm(list = ls())
mywd='C:/Users/mde4023/Downloads/FDR_Datasplitting'
setwd(mywd)
source(paste0(mywd,'/Functions/HelperFunctions.R'))
#source(paste0(mywd,'/Scenario/Scenario3c/TriangleLassoHD.R'))
source(paste0(mywd,'/Scenario/Scenario3c/MarsParallelHD.R'))
source(paste0(mywd,'/Functions Dai/knockoff.R'))
source(paste0(mywd,'/Functions Dai/analysis.R'))
source(paste0(mywd,'/Functions Dai/MBHq.R'))
source(paste0(mywd,'/Functions Dai/DS.R'))
source(paste0(mywd,'/Functions Dai/fdp_power.R'))
#devtools::install_github("Jeremy690/DSfdr/DSfdr",force = TRUE)
library(MASS)
library(glmnet)
library(knockoff)
library(mvtnorm)
library(hdi)
library(parallel)
### algorithmic settings
num_split <- 5
n <-400
p <- 500
p0 <- 25
q <- 0.1
set.seed(456)
signal_index <- sample(c(1:p), size = p0, replace = F)
#######set up the method for the comparison#############  s=15;i=10
Compare_SignalStrength <- function(i, s) {
set.seed(s)
delta <- i
# simulate data
n1 <- floor(n/2); n2 <- n - n1
X1 <- matrix(rnorm(n1*p, mean= -1), n1, p)
X2 <- matrix(rnorm(n2*p, mean= 1), n2, p)
X  <- rbind(X1, X2)
beta_star <- numeric(p)
beta_star[signal_index] <- rnorm(p0, 0, delta*sqrt(log(p)/n))*10
y <- (X %*% beta_star + rnorm(n))
# run your custom methods
g1 <- ApplyMarsTrain_HDparallel( X = X, y = y, q = q, num_split = num_split,
signal_index = signal_index, myseed = 1)
print(g1)
# FDR methods
DS_result      <- DS(          X = X, y = y, q = q, num_split = num_split)
knockoff_result<- knockoff(    X = X, y = y, q = q)
BH_result      <- MBHq(        X = X, y = y, q = q, num_split = num_split)
# init empty results df
ResultsDataFrame <- data.frame(
Method = character(),
Delta  = numeric(),
FDP    = numeric(),
Power  = numeric(),
stringsAsFactors = FALSE
)
# bind all rows
ResultsDataFrame <- rbind(
ResultsDataFrame,
data.frame(Method = "Boost DS",                Delta = i, FDP = g1$DS_fdp,    Power = g1$DS_power),
data.frame(Method = "Boost MS",                Delta = i, FDP = g1$MDS_fdp,   Power = g1$MDS_power),
data.frame(Method = "DataSplitting",           Delta = i, FDP = DS_result$DS_fdp,  Power = DS_result$DS_power),
data.frame(Method = "MultipleDataSplitting",   Delta = i, FDP = DS_result$MDS_fdp, Power = DS_result$MDS_power),
data.frame(Method = "Knockoff",                Delta = i, FDP = knockoff_result$fdp, Power = knockoff_result$power),
data.frame(Method = "Benjamini-Hochberg (BH)", Delta = i, FDP = BH_result$fdp,     Power = BH_result$power)
)
return(ResultsDataFrame)
}
Compare_SignalStrength(i=10,s=5)

#hist(mirror[-signal_index])
selected_index <- SelectFeatures(mirror, abs(mirror),q=0.1)
selected_index
num_sel <- length(selected_index)
num_sel
inc_row <- numeric(p)
fdp_val <- 0
pow_val <- 0
if (num_sel > 0) {
inc_row[selected_index] <- 1 / num_sel
}
c(num_sel, R2orig1, R2orig2, inc_row)
inc_row
num_sel
lm
mars_poly= earth(
y ~ .,
thresh=0,
data    = dataTrain
)
lm <- mars_poly
lm
# --- R^2 on train (not stored) / test halves (stored) ---?earth
pred1 <- predict(lm, newdata = as.data.frame(X[sample_index1, , drop = FALSE]))
pred2 <- predict(lm, newdata = as.data.frame(X[sample_index2, , drop = FALSE]))
y1 <- y[sample_index1]; y2 <- y[sample_index2]
R2orig1 <- 1 - sum((y1 - pred1)^2) / sum((y1 - mean(y1))^2)
R2orig2 <- 1 - sum((y2 - pred2)^2) / sum((y2 - mean(y2))^2)
R2orig1;R2orig2
# --- permutation-based drops ---
Rnew1 <- sapply(seq_len(p), function(j)
permR2Mars(as.data.frame(X[sample_index1, , drop = FALSE]), Y = y1, j = j, model = lm))
Rnew2 <- sapply(seq_len(p), function(j)
permR2Mars(as.data.frame(X[sample_index2, , drop = FALSE]), Y = y2, j = j, model = lm))
beta1 <- R2orig1 - Rnew1
beta2 <- R2orig2 - Rnew2
mirror <- sign(beta1 * beta2) * (abs(beta1) + abs(beta2))
#hist(mirror[-signal_index])
selected_index <- SelectFeatures(mirror, abs(mirror),q=0.1)
selected_index
mars_poly= earth(
y ~ .,
pmethod = "backward",
thresh=0,
data    = dataTrain
)
lm <- mars_poly
lm
# --- R^2 on train (not stored) / test halves (stored) ---?earth
pred1 <- predict(lm, newdata = as.data.frame(X[sample_index1, , drop = FALSE]))
pred2 <- predict(lm, newdata = as.data.frame(X[sample_index2, , drop = FALSE]))
y1 <- y[sample_index1]; y2 <- y[sample_index2]
R2orig1 <- 1 - sum((y1 - pred1)^2) / sum((y1 - mean(y1))^2)
R2orig2 <- 1 - sum((y2 - pred2)^2) / sum((y2 - mean(y2))^2)
R2orig1;R2orig2
# --- permutation-based drops ---
Rnew1 <- sapply(seq_len(p), function(j)
permR2Mars(as.data.frame(X[sample_index1, , drop = FALSE]), Y = y1, j = j, model = lm))
Rnew2 <- sapply(seq_len(p), function(j)
permR2Mars(as.data.frame(X[sample_index2, , drop = FALSE]), Y = y2, j = j, model = lm))
beta1 <- R2orig1 - Rnew1
beta2 <- R2orig2 - Rnew2
mirror <- sign(beta1 * beta2) * (abs(beta1) + abs(beta2))
#hist(mirror[-signal_index])
selected_index <- SelectFeatures(mirror, abs(mirror),q=0.1)
num_sel <- length(selected_index)
num_sel
mars_poly= earth(
y ~ .,
pmethod = "seqrep",
thresh=0,
data    = dataTrain
)
lm <- mars_poly
lm
# --- R^2 on train (not stored) / test halves (stored) ---?earth
pred1 <- predict(lm, newdata = as.data.frame(X[sample_index1, , drop = FALSE]))
pred2 <- predict(lm, newdata = as.data.frame(X[sample_index2, , drop = FALSE]))
y1 <- y[sample_index1]; y2 <- y[sample_index2]
R2orig1 <- 1 - sum((y1 - pred1)^2) / sum((y1 - mean(y1))^2)
R2orig2 <- 1 - sum((y2 - pred2)^2) / sum((y2 - mean(y2))^2)
R2orig1;R2orig2
# --- permutation-based drops ---
Rnew1 <- sapply(seq_len(p), function(j)
permR2Mars(as.data.frame(X[sample_index1, , drop = FALSE]), Y = y1, j = j, model = lm))
Rnew2 <- sapply(seq_len(p), function(j)
permR2Mars(as.data.frame(X[sample_index2, , drop = FALSE]), Y = y2, j = j, model = lm))
beta1 <- R2orig1 - Rnew1
beta2 <- R2orig2 - Rnew2
mirror <- sign(beta1 * beta2) * (abs(beta1) + abs(beta2))
mirror
mirror
#hist(mirror[-signal_index])
selected_index <- SelectFeatures(mirror, abs(mirror),q=0.1)
num_sel <- length(selected_index)
num_sel
train_index <- sample.int(n, size = floor(amountTrain * n), replace = FALSE)
remaining_index <- setdiff(seq_len(n), train_index)
# split the remaining half evenly
size_half <- floor((amountTest/2) * n)
sample_index1 <- sample(remaining_index, size = size_half, replace = FALSE)
sample_index2 <- setdiff(remaining_index, sample_index1)
dataTrain <- data[train_index, , drop = FALSE]
mars_poly= earth(
y ~ .,
pmethod = "seqrep",
thresh=0,
data    = dataTrain
)
lm <- mars_poly
lm
# --- R^2 on train (not stored) / test halves (stored) ---?earth
pred1 <- predict(lm, newdata = as.data.frame(X[sample_index1, , drop = FALSE]))
pred2 <- predict(lm, newdata = as.data.frame(X[sample_index2, , drop = FALSE]))
y1 <- y[sample_index1]; y2 <- y[sample_index2]
R2orig1 <- 1 - sum((y1 - pred1)^2) / sum((y1 - mean(y1))^2)
R2orig2 <- 1 - sum((y2 - pred2)^2) / sum((y2 - mean(y2))^2)
R2orig1;R2orig2
# --- permutation-based drops ---
Rnew1 <- sapply(seq_len(p), function(j)
permR2Mars(as.data.frame(X[sample_index1, , drop = FALSE]), Y = y1, j = j, model = lm))
Rnew2 <- sapply(seq_len(p), function(j)
permR2Mars(as.data.frame(X[sample_index2, , drop = FALSE]), Y = y2, j = j, model = lm))
beta1 <- R2orig1 - Rnew1
beta2 <- R2orig2 - Rnew2
mirror <- sign(beta1 * beta2) * (abs(beta1) + abs(beta2))
#hist(mirror[-signal_index])
selected_index <- SelectFeatures(mirror, abs(mirror),q=0.1)
num_sel <- length(selected_index)
num_sel
mars_poly= earth(
y ~ .,
pmethod = "seqrep",
thresh=0,
data    = dataTrain
)
lm <- mars_poly
lm
# --- R^2 on train (not stored) / test halves (stored) ---?earth
pred1 <- predict(lm, newdata = as.data.frame(X[sample_index1, , drop = FALSE]))
pred2 <- predict(lm, newdata = as.data.frame(X[sample_index2, , drop = FALSE]))
y1 <- y[sample_index1]; y2 <- y[sample_index2]
R2orig1 <- 1 - sum((y1 - pred1)^2) / sum((y1 - mean(y1))^2)
R2orig2 <- 1 - sum((y2 - pred2)^2) / sum((y2 - mean(y2))^2)
R2orig1;R2orig2
# --- permutation-based drops ---
Rnew1 <- sapply(seq_len(p), function(j)
permR2Mars(as.data.frame(X[sample_index1, , drop = FALSE]), Y = y1, j = j, model = lm))
Rnew2 <- sapply(seq_len(p), function(j)
permR2Mars(as.data.frame(X[sample_index2, , drop = FALSE]), Y = y2, j = j, model = lm))
beta1 <- R2orig1 - Rnew1
beta2 <- R2orig2 - Rnew2
mirror <- sign(beta1 * beta2) * (abs(beta1) + abs(beta2))
hist(mirror)
#hist(mirror)
selected_index <- SelectFeatures(mirror, abs(mirror),q=0.25)
selected_index
num_sel <- length(selected_index)
num_sel
inc_row <- numeric(p)
fdp_val <- 0
pow_val <- 0
if (num_sel > 0) {
inc_row[selected_index] <- 1 / num_sel
}
c(num_sel, R2orig1, R2orig2, inc_row)
#hist(mirror)
selected_index <- SelectFeatures(mirror, abs(mirror),q=0.1)
selected_index
setwd('C:/Users/mde4023/Downloads/MLRepo-master/MLRepo-master/datasets/yatsunenko')
setwd("C:/Users/mde4023/Downloads/MLRepo-master/MLRepo-master/datasets/yatsunenko/refseq")
otu    <- read.table(paste0(path, "otutable.txt"), header = TRUE, sep = "\t", row.names = 1)
otu    <- read.table(paste0(path, "otutable.txt"), header = TRUE, sep = "\t", row.names = 1)
otu    <- read_delim("otutable.txt", delim = "\t",
escape_double = FALSE, trim_ws = TRUE)
lirary(readr)
library(readr)
library(readr)
# Fetch the specific dataset (YatsunenkoT_2012)
# dryrun=FALSE downloads the actual data
dataset_list <- curatedMetagenomicData("YatsunenkoT_2012.relative_abundance", dryrun = FALSE)
curatedMetagenomicData("Yatsunenko", dryrun = TRUE)
otu    <- read_delim("otutable.txt", delim = "\t",
escape_double = FALSE, trim_ws = TRUE)
otu
taxa   <- read_delim("taxatable.txt", delim = "\t",
escape_double = FALSE, trim_ws = TRUE)
task.baby.age <- read.delim("C:/Users/mde4023/Downloads/MLRepo-master/MLRepo-master/datasets/yatsunenko/task-baby-age.txt", header=FALSE, comment.char="#")
View(task.baby.age)
task   <- read.delim("C:/Users/mde4023/Downloads/MLRepo-master/MLRepo-master/datasets/yatsunenko/task-baby-age.txt", header=FALSE, comment.char="#")
task
str(task)
dim(otu)
dim(taxa)
#But for modeling, it’s usually better to have samples as rows.
otu_t <- t(otu)
names(task)=c('id','age')
task
all(rownames(otu_t) %in% task$SampleID)
#name task dataset
names(task)=c('SampleID','age')
all(rownames(otu_t) %in% task$SampleID)
rownames(otu_t)
task$SampleID
all(task$SampleID %in%rownames(otu_t))
#merge task and otu datasets
data <- merge(task, otu_t, by.x="SampleID", by.y="row.names")
data
View(data)
#remove zero variance features
nzv <- apply(data[,-c(1,2)], 2, var) > 0
data_filt <- data[, c(TRUE, TRUE, nzv)]
data_filt
#name task dataset
names(task)=c('SampleID','Age')
all(task$SampleID %in%rownames(otu_t))
#merge task and otu datasets
data <- merge(task, otu_t, by.x="SampleID", by.y="row.names")
View(data)
#remove zero variance features
nzv <- apply(data[,-c(1,2)], 2, var) > 0
data_filt <- data[, c(TRUE, TRUE, nzv)]
hist(data_clr$Age, main = "Age Distribution", xlab = "Age (years)")
hist(data_filt$Age, main = "Age Distribution", xlab = "Age (years)")
library(randomForest)
rf <- randomForest(Age ~ ., data = data_clr, importance = TRUE)
rf <- randomForest(Age ~ ., data = data_filt, importance = TRUE)
rf
rf
library(readr)
library(doParallel)
library(doRNG)      # Reproducible parallel random numbers
library(microbiome)
library(earth)
library(dplyr)
library(earth)        # MARS
library(foreach)
library(doParallel)
library(doRNG)
# Function to calculate Permuted R2 for a specific feature j
permR2Mars <- function(data, Y, j, model) {
Xperm <- data
# Permute column j
Xperm[, j] <- sample(data[, j], replace = FALSE)
# Predict using permuted data
pred_perm <- predict(model, newdata = as.data.frame(Xperm))
# Calculate R2
rsq_perm <- 1 - sum((Y - pred_perm)^2) / sum((Y - mean(Y))^2)
return(rsq_perm)
}
# Function to Select Features based on Mirror Statistics (FDR control)
# Recreates logic likely found in your original "SelectFeatures" function
SelectFeatures <- function(mm, ww, q){
### mm: mirror statistics mm=M
### ww: absolute value of mirror statistics ww=abs(M)
### q:  FDR control level q=0.1
cutoff_set <- max(ww)
for(t in ww){
ps <- length(mm[mm > t])
ng <- length(na.omit(mm[mm < -t]))
rto <- (ng+1)/max(ps, 1)
if(rto <= q){
cutoff_set <- c(cutoff_set, t)
}
}
cutoff <- min(cutoff_set)
selected_index <- which(mm > cutoff)
return(selected_index)
}
# ==============================================================================
# 4. Parameters and Parallel Setup
# ==============================================================================
amountTrain <- 0.5
amountTest  <- 1 - amountTrain
num_split   <- 10   # Number of data splits
q_level     <- 0.10 # Target FDR level
# ==============================================================================
# 5. Main Parallel Loop (Data Splitting)
# ==============================================================================
res_mat <- foreach(iter = 1:num_split,
.combine = "rbind",
.packages = c("earth"),
.export   = c("permR2Mars","SelectFeatures","CalculateFDP_Power")) %dorng% {
# --- indices ---
train_index <- sample.int(n, size = floor(amountTrain * n), replace = FALSE)
remaining_index <- setdiff(seq_len(n), train_index)
# split the remaining half evenly
size_half <- floor((amountTest/2) * n)
sample_index1 <- sample(remaining_index, size = size_half, replace = FALSE)
sample_index2 <- setdiff(remaining_index, sample_index1)
dataTrain <- data[train_index, , drop = FALSE]
mars_poly= earth(
y ~ .,
pmethod = "seqrep",
thresh=0,
data    = dataTrain
)
lm <- mars_poly
lm
# --- R^2 on train (not stored) / test halves (stored) ---?earth
pred1 <- predict(lm, newdata = as.data.frame(X[sample_index1, , drop = FALSE]))
pred2 <- predict(lm, newdata = as.data.frame(X[sample_index2, , drop = FALSE]))
y1 <- y[sample_index1]; y2 <- y[sample_index2]
R2orig1 <- 1 - sum((y1 - pred1)^2) / sum((y1 - mean(y1))^2)
R2orig2 <- 1 - sum((y2 - pred2)^2) / sum((y2 - mean(y2))^2)
R2orig1;R2orig2
# --- permutation-based drops ---
Rnew1 <- sapply(seq_len(p), function(j)
permR2Mars(as.data.frame(X[sample_index1, , drop = FALSE]), Y = y1, j = j, model = lm))
Rnew2 <- sapply(seq_len(p), function(j)
permR2Mars(as.data.frame(X[sample_index2, , drop = FALSE]), Y = y2, j = j, model = lm))
beta1 <- R2orig1 - Rnew1
beta2 <- R2orig2 - Rnew2
mirror <- sign(beta1 * beta2) * (abs(beta1) + abs(beta2))
#hist(mirror)
selected_index <- SelectFeatures(mirror, abs(mirror),q=0.1)
num_sel <- length(selected_index)
num_sel
inc_row <- numeric(p)
fdp_val <- 0
pow_val <- 0
if (num_sel > 0) {
inc_row[selected_index] <- 1 / num_sel
}
c(num_sel, R2orig1, R2orig2, inc_row)
}
hist(data$Age, main = "Age Distribution", xlab = "Age (years)")
# ==============================================================================
# 4. Parameters and Parallel Setup
# ==============================================================================
amountTrain <- 0.5
amountTest  <- 1 - amountTrain
num_split   <- 10   # Number of data splits
q_level     <- 0.10 # Target FDR level
# --- indices ---
train_index <- sample.int(n, size = floor(amountTrain * n), replace = FALSE)
n
n= nrow(data)
p=ncol(data)-1
# --- indices ---
train_index <- sample.int(n, size = floor(amountTrain * n), replace = FALSE)
remaining_index <- setdiff(seq_len(n), train_index)
# split the remaining half evenly
size_half <- floor((amountTest/2) * n)
sample_index1 <- sample(remaining_index, size = size_half, replace = FALSE)
sample_index2 <- setdiff(remaining_index, sample_index1)
dataTrain <- data[train_index, , drop = FALSE]
dataTrain
y
mars_poly= earth(
Age ~ .,
pmethod = "seqrep",
thresh=0,
data    = dataTrain
)
lm <- mars_poly
lm
# --- R^2 on train (not stored) / test halves (stored) ---?earth
pred1 <- predict(lm, newdata = as.data.frame(X[sample_index1, , drop = FALSE]))
data
View(data)
X=data[,-1]
X
# --- R^2 on train (not stored) / test halves (stored) ---?earth
pred1 <- predict(lm, newdata = as.data.frame(X[sample_index1, , drop = FALSE]))
sample_index1
sample_index2
X
# --- R^2 on train (not stored) / test halves (stored) ---?earth
pred1 <- predict(lm, newdata = as.data.frame(X[sample_index1, , drop = FALSE]))
lm
as.data.frame(X[sample_index1, , drop = FALSE])
predict(lm, newdata = as.data.frame(X[sample_index1, , drop = FALSE]))
dataTrain
data=data[,-1]
View(data)
hist(data$Age, main = "Age Distribution", xlab = "Age (years)")
# ==============================================================================
# 4. Parameters and Parallel Setup
# ==============================================================================
amountTrain <- 0.5
amountTest  <- 1 - amountTrain
num_split   <- 10   # Number of data splits
q_level     <- 0.10 # Target FDR level
n= nrow(data)
p=ncol(data)-1
X=data[,-c(1)]
y=data$Age
y
X
# --- indices ---
train_index <- sample.int(n, size = floor(amountTrain * n), replace = FALSE)
remaining_index <- setdiff(seq_len(n), train_index)
# split the remaining half evenly
size_half <- floor((amountTest/2) * n)
sample_index1 <- sample(remaining_index, size = size_half, replace = FALSE)
sample_index2 <- setdiff(remaining_index, sample_index1)
dataTrain <- data[train_index, , drop = FALSE]
mars_poly= earth(
Age ~ .,
pmethod = "seqrep",
thresh=0,
data    = dataTrain
)
lm <- mars_poly
lm
# --- R^2 on train (not stored) / test halves (stored) ---?earth
pred1 <- predict(lm, newdata = as.data.frame(X[sample_index1, , drop = FALSE]))
# --- R^2 on train (not stored) / test halves (stored) ---?earth
pred1 <- predict(lm, newdata = X[sample_index1,])
X
lm
# --- R^2 on train (not stored) / test halves (stored) ---?earth
pred1 <- predict(lm, newdata = X[sample_index1,])
predict(lm, newdata = X[sample_index1,])
# Function to calculate Permuted R2 for a specific feature j
permR2Mars <- function(data, Y, j, model) {
Xperm <- data
# Permute column j
Xperm[, j] <- sample(data[, j], replace = FALSE)
# Predict using permuted data
pred_perm <- predict(model, newdata = as.data.frame(Xperm))
# Calculate R2
rsq_perm <- 1 - sum((Y - pred_perm)^2) / sum((Y - mean(Y))^2)
return(rsq_perm)
}
# Function to Select Features based on Mirror Statistics (FDR control)
# Recreates logic likely found in your original "SelectFeatures" function
SelectFeatures <- function(mm, ww, q){
### mm: mirror statistics mm=M
### ww: absolute value of mirror statistics ww=abs(M)
### q:  FDR control level q=0.1
cutoff_set <- max(ww)
for(t in ww){
ps <- length(mm[mm > t])
ng <- length(na.omit(mm[mm < -t]))
rto <- (ng+1)/max(ps, 1)
if(rto <= q){
cutoff_set <- c(cutoff_set, t)
}
}
cutoff <- min(cutoff_set)
selected_index <- which(mm > cutoff)
return(selected_index)
}
# ==============================================================================
# 3. Data Preparation
# ==============================================================================
setwd("C:/Users/mde4023/Downloads/MLRepo-master/MLRepo-master/datasets/yatsunenko/refseq")
task   <- read.delim("C:/Users/mde4023/Downloads/MLRepo-master/MLRepo-master/datasets/yatsunenko/task-baby-age.txt", header=FALSE, comment.char="#")
otu    <- read_delim("otutable.txt", delim = "\t",
escape_double = FALSE, trim_ws = TRUE)
taxa   <- read_delim("taxatable.txt", delim = "\t",
escape_double = FALSE, trim_ws = TRUE)
str(task)
dim(otu)
dim(taxa)
#But for modeling, it’s usually better to have samples as rows.
otu_t <- t(otu)
#name task dataset
names(task)=c('SampleID','Age')
all(task$SampleID %in%rownames(otu_t))
#merge task and otu datasets
data <- merge(task, otu_t, by.x="SampleID", by.y="row.names")
data=data[,-1]
data
hist(data$Age, main = "Age Distribution", xlab = "Age (years)")
# ==============================================================================
# 4. Parameters and Parallel Setup
# ==============================================================================
amountTrain <- 0.5
amountTest  <- 1 - amountTrain
num_split   <- 10   # Number of data splits
q_level     <- 0.10 # Target FDR level
n= nrow(data)
p=ncol(data)-1
# Setup Parallel Backend
n_cores <- max(1, parallel::detectCores(logical = TRUE) - 1)
cl <- parallel::makeCluster(n_cores)
registerDoParallel(cl)
registerDoRNG(123) # Set seed for reproducibility
X=data[,-c(1)]
names(X)=paste0('X',1:p)
X
y=data$Age
data=cbind(y,X)
data
# split the remaining half evenly
size_half <- floor((amountTest/2) * n)
sample_index1 <- sample(remaining_index, size = size_half, replace = FALSE)
sample_index2 <- setdiff(remaining_index, sample_index1)
dataTrain <- data[train_index, , drop = FALSE]
mars_poly= earth(
y ~ .,
pmethod = "seqrep",
thresh=0,
data    = dataTrain
)
gc()
mars_poly= earth(
y ~ .,
pmethod = "seqrep",
thresh=0,
data    = dataTrain
)
lm <- mars_poly
lm
# --- R^2 on train (not stored) / test halves (stored) ---?earth
pred1 <- predict(lm, newdata = X[sample_index1,])
pred2 <- predict(lm, newdata = X[sample_index2,])
X[sample_index1,]
dataTrain
